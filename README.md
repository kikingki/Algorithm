# Algorithm🌱
#### 20.12.26
  + ##### [BOJ 1259](../master/1259번.py)
    입력된 수가 팰린드롬 수인지 판단하는 문제. 
    input으로 0이 들어올 경우 break로 프로그램을 종료했고, 반복문으로 리스트를 앞과 뒤에서 순차적으로 비교하여 틀릴 경우 'no'를 출력했다.
  + ##### [BOJ 11004](../master/11004번.py)
    N개의 수를 오름차순 정렬했을 때, 앞에서부터 K번째 있는 수를 구하는 문제. 
    map 메소드로 입력된 수를 int형으로 변환하고 list 자료형으로 바꿨다. 그 후 sort 메소드를 사용해 정렬한 후 인덱스를 이용해 풀었다.
    + sort는 리스트 원본을 직접 수정하고, sorted는 정렬된 새로운 리스트를 반환한다.

#### 21.1.5
  + ##### [BOJ 17219](../master/17219번.py)
    가입한 사이트와 비밀번호를 저장하고, 비밀번호를 찾으려는 사이트 주소를 입력하면 해당 사이트의 비밀번호를 출력하는 문제. 딕셔너리 자료형을 이용해 풀었고, 첫 시도에 맞추긴 했지만 input을 사용했을 때 입력 값이 많다보니 시간이 너무 오래 걸린다는 단점이 있었다. readline 함수를 사용하니 속도가 훨씬 단축됐다.
  + ##### [BOJ 1978](../master/1978번.py)
    주어진 N개의 수 중 소수를 찾는 문제. 에라토스테너스의 체 알고리즘을 이용했다. 입력받은 리스트에서 가장 큰 값을 구해 에라토스테너스의 체로 소수 리스트를 만들고, 반복문을 돌려 소수 리스트 중 입력된 수의 개수만 더해 출력했다.
    + 소수를 찾는 반복문을 돌릴 때 √N까지만 확인하는 방법이 시간복잡도가 O(√N)으로 가장 효율적이다.

#### 21.1.13
  + #### [BOJ 1018](../master/1018번.py)
    MxN 크기의 보드판을 8x8크기로 잘라 체스판으로 사용하기 위해 바꿔 칠해야하는 최소 횟수를 구하는 문제. 브루트포스 알고리즘을 이용했다. 행과 열의 인덱스 합으로 조건문을 구성하여 쉽게 체크무늬인지 확인할 수 있었다. 첫 칸이 검은색일 경우 칠해야 하는 수와 첫 칸이 흰색일 경우 칠해야 하는 수를 각각 모두 세고 count_list에 추가한 후 최솟값을 출력했다.
    + 브루트포스 알고리즘은 시간과 자원을 아주 많이 소요된다는 점이 단점이지만 정확도는 100%이다.

#### 21.1.14
  + #### [BOJ 11399](../master/11399번.py)
    N명의 사람들이 ATM에서 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 문제. 그리디 알고리즘을 이용했다. 인출시간이 빠른 순서대로 인출하는 것이 그 순간의 최적 선택이므로 sort() 메서드로 정렬했다. 반복문으로 각 사람이 인출하는데 걸리는 시간을 sum에 누적시킨 후, time에 모두 더해 시간의 합을 구했다.
    
    
    (수정) min과 sum이 오버라이딩되므로 min을 t로, sum을 ac로 수정했고, map 객체를 리스트로 바꾸지 않고 sorted() 메서드로 바로 정렬하도록 수정했다.
    + 그리디 알고리즘은 그 순간에서 최적인 경우를 선택하는 것이므로 전체적으로 봤을 때 가장 최적이라고 할 수는 없다. 탐욕스러운 선택 조건, 최적 부분 구조 조건이라는 조건이 성립되면 그리디 알고리즘으로 가장 최적의 선택을 구할 수도 있다. 하지만 계산속도가 빨라 근사 알고리즘으로 사용하기 좋다.

  #### 21.1.15
  + #### [BOJ 1110](../master/1110번.py)
    입력받은 수의 각 자리의 수를 더한 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙여 새로운 수를 만들고 이를 반복해 새로운 수가 처음 입력값과 같아질 때 까지 걸리는 횟수를 구하는 문제. 문자열의 슬라이싱을 이용해 주어진 수의 일의 자리 수와 새로운 수의 일의 자리 수를 이어 붙였고 이를 반복하다가 초기값과 새로운 수가 같으면 반복을 종료했다. 문자열로 풀었기 때문에 10 이하의 수이면 십의 자리에 '0'을 추가했다. 
    
    
    (수정) 슬라이싱을 사용해 풀었었는데 다른 풀이를 참고해보니 문자열로 변환하지 않고 %와 //를 활용하면 더 쉽게 풀 수 있음을 알게 됐다. int형이므로 n이 10이하일 경우를 고려해 코드를 추가하지 않아도 돼서 간단했다. 그리고 if문을 while문의 처음에 넣었을 때, 입력이 0일 경우에 무한반복에 걸려 오류가 나서 cycle이 1 이상이라는 조건을 추가했었다. 하지만 if문을 while문의 맨마지막에 작성하면 자연스럽게 cycle이 한번은 돌기 때문에 추가적인 조건을 덧붙이지 않아도 됨을 알게 됐다. 이 문제를 풀면서 코드의 순서 역시 중요하게 생각해야 함을 느꼈다.

#### 21.1.19
  + #### [BOJ 2798](../master/2798번.py)
    N장의 카드에서 3개의 카드를 골라 그 합이 M과 가장 가까운 값을 구하는 문제. 브루트포스 알고리즘을 이용해 풀었다. for문을 중첩해 모든 카드의 합을 구하면서 M보다 작은 값 중 최댓값을 구했다.

#### 21.1.20
  + #### [BOJ 10866](../master/10866번.py)
    정수를 저장하는 덱(Deque)을 구현한 다음, 입력으로 주어지는 프로그램을 작성하는 문제. Deque 클래스를 만들고 8가지 명령을 리스트의 insert(), append(), pop() 메서드를 사용해 함수로 만들었다. 그리고 main에서 Deque 객체를 만들고 입력을 받아 조건에 맞는 함수를 불러왔다. 다양한 리스트 함수를 정확히 활용할 수 있게 됐고, 리스트를 끝에서부터 불러오고 싶으면 인덱스로 -n을 사용해서 간결히 해결할 수 있음을 알게 됐다.
    + 리스트로 deque를 구현했는데, insert() 메서드는 모든 요소가 메모리에서 이동될 수 있어 최악 경우 시간복잡도가 O(N)이므로 비효율적이라고 한다. 파이썬에서 제공하는 collections 패키지의 deque 모듈은 이중 연결 리스트로 구현하여 O(1) 시간에 연산이 가능하다. 

#### 21.1.22
  + #### [BOJ 2941](../master/2941번.py)
    입력한 단어에서 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력하는 문제. 처음엔 크로아티아 알파벳을 croa 리스트에 저장하고, word 변수에 입력 값을 저장했다. 이 리스트로 반복문을 돌고, if문으로 word 안에 크로아티아 알파벳이 있으면 count 값을 증가하는 방법으로 풀었다. 이렇게 푸니 'dz=' 알파벳의 경우 'z='와 중복돼 count가 2번 증가하는 문제가 발생했다. 그래서 replace() 메서드를 이용해 크로아티아 알파벳을 공백 문자로 치환한 다음 len(word)를 출력해 해결했다. 리스트를 순차적으로 순회하기 때문에 리스트에 'z='가 'dz='보다 앞 순서이면 'dz='가 'd '로 치환되는 문제가 있을 수 있으니 순서를 유의해야할 것 같다.

#### 21.1.24
  + #### [BOJ 1427](../master/1427번.py)
    한줄로 입력받을 수를 내림차로 정렬한 후 출력하는 문제. sorted(reverse=True)로 내림차순 정렬을 했다. 문자열을 리스트로 분할하는 split() 메서드는 많이 사용해봤는데, 반대로 리스트를 문자열로 합치는 join() 메서드는 처음 사용해봤다.
    + sorted(reverse=True)는 기준에 따라 내림차순 정렬을 하는 것이고, reverse()는 단순히 리스트의 순서를 뒤집는 것이므로 잘 구분해야 한다.
  + #### [BOJ 10828](../master/10828번.py)
    정수를 저장하는 스택(Stack)을 구현한 다음, 입력으로 주어지는 프로그램을 작성하는 문제. Stack 클래스를 만들고 pop(), append() 메서드를 사용해 함수를 구현했다. 스택은 배열의 끝에서만 데이터에 접근이 가능한 LIFO 구조이기 때문에 시간복잡도가 모두 O(1)이다. 
    + 스택은 깊이 우선 탐색(DFS)에서 유용하게 사용된다.

#### 21.1.27
  + #### [BOJ 1260](../master/1260번.py)
    그래프를 깊이 우선 탐색(DFS)로 탐색한 결과와 너비 우선 탐색(BFS)로 탐색한 결과를 출력하는 문제. DFS는 스택, BFS는 큐를 사용하여 구현했다. 큐와 스택이 혼합된 구조인 collections 모듈의 deque를 사용했다. 생성한 deque 객체를 반복하며 방문하지 않은 정점일 경우 visited 리스트에 추가했다. 방문할 수 있는 정점이 여러개인 경우, 정점 번호가 작은 것을 방문하는 것이 조건이므로 stack은 내림차순 정렬, queue는 오름차순 정렬을 했다. 그리고 visited 리스트를 문자열로 변환한 뒤 반환했다. main에선 간선의 개수만큼 x,y를 입력받은 후, key의 value가 이미 있을 경우 append()로 value를 추가하고, 아닐 경우 딕셔너리 쌍을 추가했다. 또한, 양방향 연결이므로 x,y와 y,x를 모두 연결했다.
    + 백준에 제출해보니 런타임에러(KeyError)가 떠서 찾아보니 딕셔너리에 해당하는 key가 없을 때 발생하는 오류라고 한다. 각 함수에 조건문 if key in dict를 추가해 해결했다.
    
#### 21.1.28
  + #### [BOJ 2606](../master/2606번.py)
    웜 바이러스에 걸린 1번 컴퓨터를 통해 감염된 컴퓨터의 수를 출력하는 문제. 1번 컴퓨터와 연결된 모든 경로를 확인해야 할 경우 깊이 우선 탐색(DFS)이 적합하므로 dfs를 구현해 풀었다. bfs 메서드에서 감염된 컴퓨터 수를 세는 cnt 변수에서 1번 컴퓨터를 제외해야 하므로 cnt-1을 반환했다.
    + 너비 우선 탐색(BFS)은 일반적으로 목표지점까지의 최단 경로를 찾을 때 사용한다.

#### 21.1.29
  + #### [BOJ 2748](../master/2748번.py)
    n번째 피보나치 수를 구하는 문제. 처음에 재귀 호출을 이용하여 풀었을 때, 시간초과가 발생했다. 이유를 찾아봤더니 재귀함수를 사용할 경우 중복되는 연산이 발생해 시간복잡도가 O(2**n)이라고 한다. 반복문을 사용할 경우 시간복잡도가 O(n)이라고 하여 반복문을 n번 돌려 피보나치 수를 구했다.

#### 21.1.30
  + #### [BOJ 2217](../master/2217번.py)
    정보가 주어진 각 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구하는 문제. 리스트에 로프의 최대 중량을 입력받았다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 로프를 병렬로 연결하면 "각 로프에는 w/k만큼의 동일한 중량"이 걸리고, 모든 로프를 사용할 필요가 없다는 점이 포인트다. 입력받은 리스트를 최대 중량이 큰 순서대로(역순) 정렬한 후, 1번 로프가 견딜 수 있는 중량 x 1, 1번 로프와 2번 로프가 견딜 수 있는 중량 x 2 ... 식으로 반복해 최댓값을 리턴하는 함수를 작성했다. 
    + 첫 시도가 성공은 했지만 시간이 너무 오래걸려 readline() 메서드를 사용해보니 3948ms에서 140ms으로 시간이 크게 단축됐다. 로프의 갯수의 범위가 (1 ≤ N ≤ 100,000)이라는 큰 수이기 때문에 차이가 크다는 것을 느꼈다.

#### 21.1.31
  + #### [BOJ 2839](../master/2839번.py)
    Nkg의 설탕을 3kg 봉지와 5kg 봉지로 정확히 Nkg이면서 또 최소한인 봉지의 개수를 출력하는 문제. 반복문을 사용하지 않고 한번에 나눗셈과 나머지 연산을 실행했더니 3kg 봉지로만 정확히 나누어 떨어지는 경우에도 -1이 출력이 됐다. 방법을 바꿔 5kg의 배수로 딱 나뉘어 떨어질 때까지 설탕의 무게를 3kg씩 빼고 봉지의 개수를 1씩 더하는 것을 반복하다가 설탕의 무게가 5kg의 배수가 되면 5kg 봉지의 개수를 더한 후 봉지 개수의 총합을 출력했다. 또한 설탕의 무게가 음수가 되면 정확히 나누어지지 않는 것이므로 -1을 출력했다.